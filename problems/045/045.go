/*
Triangular, pentagonal, and hexagonal

Triangle, pentagonal, and hexagonal numbers are generated by the
following formulae:

Triangle    T(n)=n(n+1)/2    1, 3, 6, 10, 15, ...
Pentagonal  P(n)=n(3n−1)/2   1, 5, 12, 22, 35, ...
Hexagonal   H(n)=n(2n−1)     1, 6, 15, 28, 45, ...

It can be verified that T(285) = P(165) = H(143) = 40755.

Find the next triangle number that is also pentagonal and hexagonal.
*/

package main

import (
	"fmt"
)

func NewPentagonalNumbers() (*PentagonalNumbers, error) {
	return &PentagonalNumbers{
		n: make(chan int, 0),
	}, nil
}

type PentagonalNumbers struct {
	n chan int
}

func (pn PentagonalNumbers) Generate() {
	val := 1
	i := 1
	for {
		pn.n <- val
		val += 3*i + 1
		i++
	}
}

func NewTriangularNumbers() (*TriangularNumbers, error) {
	return &TriangularNumbers{
		n: make(chan int, 0),
	}, nil
}

type TriangularNumbers struct {
	n chan int
}

func (tn *TriangularNumbers) Generate() {
	val := 0
	i := 1
	for {
		val += i
		tn.n <- val
		i++
	}
}

func NewHexagonalNumbers() (*HexagonalNumbers, error) {
	return &HexagonalNumbers{
		n: make(chan int, 0),
	}, nil
}

type HexagonalNumbers struct {
	n chan int
}

func (hn *HexagonalNumbers) Generate() {
	i := 2
	val := 1
	for {
		hn.n <- val
		val += 4*i - 3
		i++
	}
}

func main() {
	fmt.Println("Triangular, pentagonal, and hexagonal")

	tn, _ := NewTriangularNumbers()
	go tn.Generate()
	pn, _ := NewPentagonalNumbers()
	go pn.Generate()
	hn, _ := NewHexagonalNumbers()
	go hn.Generate()

	pn_val := 0
	tn_val := 0
	for hn_val := range hn.n {
		if hn_val <= 40755 {
			continue
		}
		for {
			if pn_val >= hn_val {
				break
			}
			pn_val = <-pn.n
		}
		for {
			if tn_val >= hn_val {
				break
			}
			tn_val = <-tn.n
		}
		if pn_val == hn_val && hn_val == tn_val {
			fmt.Println(tn_val, pn_val, hn_val)
			break
		}
	}

}
